{"version":3,"file":"ngneat-until-destroy.js","sources":["ng://@ngneat/until-destroy/lib/internals.ts","ng://@ngneat/until-destroy/lib/until-destroy.ts","ng://@ngneat/until-destroy/lib/until-destroyed.ts","ng://@ngneat/until-destroy/ngneat-until-destroy.ts"],"sourcesContent":["import {\n  InjectableType,\n  ɵComponentType as ComponentType,\n  ɵDirectiveType as DirectiveType,\n  ɵComponentDef as ComponentDef,\n  ɵDirectiveDef as DirectiveDef\n} from '@angular/core';\nimport { Subject } from 'rxjs';\n\nexport function isFunction(target: unknown) {\n  return typeof target === 'function';\n}\n\n/**\n * Applied to instances and stores `Subject` instance\n */\nexport const DESTROY: unique symbol = Symbol('__destroy');\n\n/**\n * Applied to definitions and informs that class is decorated\n */\nconst DECORATOR_APPLIED: unique symbol = Symbol('__decoratorApplied');\n\nexport function markAsDecorated(\n  providerOrDef: InjectableType<unknown> | DirectiveDef<unknown> | ComponentDef<unknown>\n): void {\n  (providerOrDef as any)[DECORATOR_APPLIED] = true;\n}\n\nexport interface UntilDestroyOptions {\n  blackList?: string[];\n  arrayName?: string;\n  checkProperties?: boolean;\n}\n\nexport function ensureClassIsDecorated(instance: any): never | void {\n  const constructor = instance.constructor;\n  const providerOrDef = isInjectableType(constructor) ? constructor : getDef(constructor);\n  const missingDecorator = !(providerOrDef as any)[DECORATOR_APPLIED];\n\n  if (missingDecorator) {\n    throw new Error(\n      'untilDestroyed operator cannot be used inside directives or ' +\n        'components or providers that are not decorated with UntilDestroy decorator'\n    );\n  }\n}\n\nexport function createSubjectOnTheInstance(instance: any): void {\n  if (!instance[DESTROY]) {\n    instance[DESTROY] = new Subject<void>();\n  }\n}\n\nexport function completeSubjectOnTheInstance(instance: any): void {\n  if (instance[DESTROY]) {\n    instance[DESTROY].next();\n    instance[DESTROY].complete();\n  }\n}\n\n/**\n * As directive and component definitions are considered private API,\n * so those properties are prefixed with Angular's marker for \"private\"\n */\nexport function getDef<T>(\n  type: DirectiveType<T> | ComponentType<T>\n): DirectiveDef<T> | ComponentDef<T> {\n  return (type as ComponentType<T>).ɵcmp || (type as DirectiveType<T>).ɵdir;\n}\n\n/**\n * Determines whether the provided `target` is some function\n * decorated with `@Injectable()`\n */\nexport function isInjectableType(target: any): target is InjectableType<unknown> {\n  return !!target.ɵprov;\n}\n","import {\n  InjectableType,\n  ɵComponentType as ComponentType,\n  ɵDirectiveType as DirectiveType\n} from '@angular/core';\n\nimport {\n  getDef,\n  isFunction,\n  UntilDestroyOptions,\n  completeSubjectOnTheInstance,\n  isInjectableType,\n  markAsDecorated\n} from './internals';\n\nfunction unsubscribe(property: any): void {\n  property && isFunction(property.unsubscribe) && property.unsubscribe();\n}\n\nfunction unsubscribeIfPropertyIsArrayLike(property: any[]): void {\n  Array.isArray(property) && property.forEach(unsubscribe);\n}\n\nfunction decorateNgOnDestroy(\n  ngOnDestroy: (() => void) | null | undefined,\n  { arrayName, checkProperties, blackList }: UntilDestroyOptions\n) {\n  return function(this: any) {\n    // Invoke the original `ngOnDestroy` if it exists\n    ngOnDestroy && ngOnDestroy.call(this);\n\n    // It's important to use `this` instead of caching instance\n    // that may lead to memory leaks\n    completeSubjectOnTheInstance(this);\n\n    // Check if subscriptions are pushed to some array\n    if (arrayName) {\n      return unsubscribeIfPropertyIsArrayLike(this[arrayName]);\n    }\n\n    // Loop through the properties and find subscriptions\n    if (checkProperties) {\n      for (const property in this) {\n        if (blackList && blackList.includes(property)) {\n          continue;\n        }\n\n        unsubscribe(this[property]);\n      }\n    }\n  };\n}\n\n/**\n * Services do not have definitions, thus we just have to override the\n * prototype property in Ivy\n */\nfunction decorateProvider(type: InjectableType<unknown>, options: UntilDestroyOptions): void {\n  type.prototype.ngOnDestroy = decorateNgOnDestroy(type.prototype.ngOnDestroy, options);\n  markAsDecorated(type);\n}\n\nfunction decorateDirective(\n  type: DirectiveType<unknown> | ComponentType<unknown>,\n  options: UntilDestroyOptions\n): void {\n  const def = getDef(type);\n  (def as any).onDestroy = decorateNgOnDestroy(def.onDestroy, options);\n  markAsDecorated(def);\n}\n\nexport function UntilDestroy(options: UntilDestroyOptions = {}): ClassDecorator {\n  return (target: any) => {\n    if (isInjectableType(target)) {\n      decorateProvider(target, options);\n    } else {\n      decorateDirective(target, options);\n    }\n  };\n}\n","import { Observable } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\nimport {\n  DESTROY,\n  isFunction,\n  createSubjectOnTheInstance,\n  completeSubjectOnTheInstance,\n  ensureClassIsDecorated\n} from './internals';\n\nfunction overrideNonDirectiveInstanceMethod(instance: any, destroyMethodName: string): void {\n  const originalDestroy = instance[destroyMethodName];\n\n  if (isFunction(originalDestroy) === false) {\n    throw new Error(\n      `${instance.constructor.name} is using untilDestroyed but doesn't implement ${destroyMethodName}`\n    );\n  }\n\n  createSubjectOnTheInstance(instance);\n\n  instance[destroyMethodName] = function() {\n    isFunction(originalDestroy) && originalDestroy.apply(this, arguments);\n    completeSubjectOnTheInstance(this);\n  };\n}\n\nexport function untilDestroyed(instance: any, destroyMethodName?: string) {\n  return <T>(source: Observable<T>) => {\n    // If `destroyMethodName` is passed then the developer applies\n    // this operator to something non-related to Angular DI system\n    if (typeof destroyMethodName === 'string') {\n      overrideNonDirectiveInstanceMethod(instance, destroyMethodName);\n    } else {\n      ensureClassIsDecorated(instance);\n      createSubjectOnTheInstance(instance);\n    }\n\n    return source.pipe(takeUntil<T>(instance[DESTROY]));\n  };\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}